# Markers by stage and by cluster - 27/06/2018
################################
#=====================================
# PS
#=====================================
cellsPS <- rownames(metaSub)[metaSub$cluster.ann=="PS/mesendoderm"]
metaSub[cellsPS,"stage"]
unique(metaSub[cellsPS,"stage"])
################################
# Markers by stage and by cluster - 27/06/2018
################################
#=====================================
# PS
#=====================================
cellsPS0 <- rownames(metaSub)[metaSub$cluster.ann=="PS/mesendoderm"]
cellsStageRight <- rownames(metaSub)[metaSub$stage!="mixed_gastrulation"]
cellsPS <- intersect(cellsPS0,cellsStageRight)
countsPS <- counts[,cellsPS]
groupsPS <- metaSub[cellsPS,"stage"]
groupsPS <- as.character(metaSub[cellsPS,"stage"])
names(groupsPS)<-cellsPS
markersPS <- anSeq::findMarkers(countsPS,groups=groupsPS)
counts0<-counts
counts<-countsPS
groups=groupsPS
genes=NULL
topGeneThres=1000
logFCThres = 0
qvalue=0.05
mode="general"
groupTarget=NULL
if (is.null(genes)){
genes <- rownames(counts)
}
#Define groups
uniq.groups <- unique(groups)
#Take those genes to take into account from the counts table.
counts <- counts[genes,]
#Create an empty matrix where you will add the upregulated genes.
genesDE <- list()
Up.genes <-matrix(, nrow=topGeneThres , ncol = length(uniq.groups))
Down.genes <-matrix(, nrow=topGeneThres , ncol = length(uniq.groups))
i=1
groupB <- as.character(uniq.groups[i])
cat (paste("\n\n\nComparing",groupB,"to others...\n"))
groupA <- "other"
groups.bias <- as.character(groups)
names(groups.bias)= names(groups)
groups.bias[names(groups.bias)[which(groups.bias != groupB)]] = groupA
groups.bias <- as.factor(groups.bias)
#Create a DGEList
dgList <- edgeR::DGEList(counts=as.matrix(counts), genes = rownames(counts),
group=groups.bias)
cat("Estimating dispersions...")
dgList <- edgeR::estimateCommonDisp(dgList, verbose=TRUE)
countsPS <- countsPS0[Matrix::rowSums(countsPS0)>0,]
countsPS0 <- counts[,cellsPS]
countsPS <- countsPS0[Matrix::rowSums(countsPS0)>0,]
dim(countsPS)
countsPS <- countsPS0[rowVars(countsPS0)>0,]
dim(countsPS)
groupsPS <- as.character(metaSub[cellsPS,"stage"])
names(groupsPS)<-cellsPS
markersPS <- anSeq::findMarkers(countsPS,groups=groupsPS)
decompPS<- smart_decomp(countsPS1,stage=metaSub[cellsPS,"stage"],
sample=metaSub[cellsPS,"sample"])
source(paste0(wd,"PhD_BPS32/release4/JonnyFiles/20180402/core_functions_Blanca_local.R"))
decompPS<- smart_decomp(countsPS1,stage=metaSub[cellsPS,"stage"],
sample=metaSub[cellsPS,"sample"])
countsPS1 <- countsPS0[rowVars(countsPS0)>0,]
source(paste0(wd,"PhD_BPS32/release4/JonnyFiles/20180402/core_functions_Blanca_local.R"))
decompPS<- smart_decomp(countsPS1,stage=metaSub[cellsPS,"stage"],
sample=metaSub[cellsPS,"sample"])
hvg <- choose_hvgs(decompPS,return.plots=TRUE)
countsPS <- countsPS1[hvg$hvgs,]
groupsPS <- as.character(metaSub[cellsPS,"stage"])
names(groupsPS)<-cellsPS
markersPS <- anSeq::findMarkers(countsPS,groups=groupsPS)
??exactTest
findMarkers <- function(counts,genes=NULL,groups,
topGeneThres=1000, logFCThres = 0,
qvalue=0.05, mode="general",groupTarget=NULL){
if (is.null(genes)){
genes <- rownames(counts)
}
#Define groups
uniq.groups <- unique(groups)
#Take those genes to take into account from the counts table.
counts <- counts[genes,]
if (mode == "general"){
#Create an empty matrix where you will add the upregulated genes.
genesDE <- list()
Up.genes <-matrix(, nrow=topGeneThres , ncol = length(uniq.groups))
Down.genes <-matrix(, nrow=topGeneThres , ncol = length(uniq.groups))
if (is.null(groupTarget)){
for (i in c(1:length(uniq.groups))){
groupB <- as.character(uniq.groups[i])
cat (paste("\n\n\nComparing",groupB,"to others...\n"))
groupA <- "other"
groups.bias <- as.character(groups)
names(groups.bias)= names(groups)
groups.bias[names(groups.bias)[which(groups.bias != groupB)]] = groupA
groups.bias <- as.factor(groups.bias)
#Create a DGEList
dgList <- edgeR::DGEList(counts=as.matrix(counts), genes = rownames(counts),
group=groups.bias)
#Estimate dispersions needed for edgeR.
cat("Estimating dispersions...")
dgList <- edgeR::estimateCommonDisp(dgList, verbose=TRUE)
dgList <- edgeR::estimateTagwiseDisp(dgList)
res <- edgeR::exactTest(dgList,pair = c(groupA , groupB))
fdr <- stats::p.adjust(res$table$PValue, method="BH")
res2 <- cbind(res$table,fdr)
res2.sort <- res2[order(res2$fdr,decreasing = FALSE),]
#res2.sort.top <- res2.sort[which(res2.sort$fdr < qvalue),]
#up <- rownames(res2.sort.top[which(res2.sort.top$logFC<(-logFCThres)),])[1:topGeneThres]
#down <- rownames(res2.sort.top[which(res2.sort.top$logFC>(logFCThres)),])[1:topGeneThres]
genesDE[[groupB]] <- res2.sort[res2.sort$fdr<qvalue,]
}
#olnames(Up.genes) = colnames(Down.genes) = uniq.groups
return(genesDE)
} else {
groupB <- groupTarget
cat (paste("\n\n\nComparing",groupB,"to others...\n"))
groupA <- "other"
groups.bias <- as.character(groups)
names(groups.bias)= names(groups)
groups.bias[names(groups.bias)[which(groups.bias != groupB)]] = groupA
groups.bias <- as.factor(groups.bias)
#Create a DGEList
dgList <- edgeR::DGEList(counts=as.matrix(counts), genes = rownames(counts),
group=groups.bias)
#Estimate dispersions needed for edgeR.
cat("Estimating dispersions...")
dgList <- edgeR::estimateCommonDisp(dgList, verbose=TRUE)
dgList <- edgeR::estimateTagwiseDisp(dgList)
res <- edgeR::exactTest(dgList,pair = c(groupA , groupB))
fdr <- stats::p.adjust(res$table$PValue, method="BH")
res2 <- cbind(res$table,fdr)
res2.sort <- res2[order(res2$fdr,decreasing = FALSE),]
res2.sort.top <- res2.sort[which(res2.sort$fdr < qvalue),]
return(res2)
}
cat("DONE!\n")
} else if (mode=="strict"){
#Create a DGEList
dgList <- edgeR::DGEList(counts=as.matrix(counts), genes = rownames(counts),
group=groups)
#Estimate dispersions needed for edgeR.
cat("\n\nEstimating dispersions...\n")
dgList <- edgeR::estimateCommonDisp(dgList, verbose=TRUE)
dgList <- edgeR::estimateTagwiseDisp(dgList)
#Create table for pairwise comparisons (pairs will be unique)
combin <- t(utils::combn(unique(c(uniq.groups,uniq.groups)) , 2 ))
#Reorder columns
combin.inv <- combin[,c(2,1)]
#Take all pairs in one direction and in the other (e.g. row with 6 4 and 4 6)
combin2 <- rbind(combin,combin.inv)
#Create an empty matrix where you will add the upregulated genes.
Up.genes <-matrix(, nrow=topGeneThres , ncol = nrow(combin2))
for (i in c(1:nrow(combin))){
#for each unique combination, define group1 and 2.
group1 <- uniq.groups[combin[i,1]]
group2 <- uniq.groups[combin[i,2]]
res <- edgeR::exactTest(dgList,pair = c( group1 , group2))
fdr <- stats::p.adjust(res$table$PValue, method="BH")
res2 <- cbind(res$table,fdr)
res2.sort <- res2[order(res2$fdr,decreasing = FALSE),]
res2.sort.top <- res2.sort[which(res2.sort$fdr < qvalue),]
up1 <- rownames(res2.sort.top[which(res2.sort.top$logFC<(-logFCThres)),])[1:topGeneThres]
idx1 <- which(((combin2[,1]==combin[i,1])&(combin2[,2]==combin[i,2]))==TRUE)
Up.genes[,idx1] <- up1
up2 <- rownames(res2.sort.top[which(res2.sort.top$logFC>(logFCThres)),])[1:topGeneThres]
idx2 <- which(((combin2[,1]==combin[i,2])&(combin2[,2]==combin[i,1]))==TRUE)
Up.genes[,idx2] <- up2
}
up.genes.merged <- list()
for (t in 1:length(uniq.groups)){
num <- length(which(combin2[,1]==t))
tab <- table(as.vector(Up.genes[,which(combin2[,1]==t)]))
up.genes.merged[[t]] <- names(tab)[which(tab == num)]
if (is.null(names(tab)[which(tab == num)])){
up.genes.merged[[t]] = c("none")
}
}
names(up.genes.merged)<-uniq.groups
return(list(
up.genes <- up.genes.merged
))
cat("DONE!\n")
}
}
markersPS <- anSeq::findMarkers(countsPS,groups=groupsPS)
markersPS <- findMarkers(countsPS,groups=groupsPS)
markersPS$E6.5
for (i in markersPS){
dim(i)
}
for (i in markersPS){
cat(dim(i),"\n")
}
type(markersPS[[i]])
i=1
type(markersPS[[i]])
type(markersPS[[i]])
typeof(markersPS[[i]])
markersPS2 <- markersPS
for (i in markersPS){
cat(dim(i),"\n")
markersPS[[i]]$geneNames <- anSeq::getGeneName(rownames(markersPS))[[2]]
}
for (i in 1:length(markersPS)){
cat(dim(i),"\n")
markersPS[[i]]$geneNames <- anSeq::getGeneName(rownames(markersPS))[[2]]
}
markersPS[[i]]
anSeq::getGeneName(rownames(markersPS))[[2]]
for (i in 1:length(markersPS)){
cat(dim(i),"\n")
markersPS[[i]]$geneNames <- anSeq::getGeneName(rownames(markersPS[[i]]))[[2]]
}
markersPS[[i]]
library(xlsx)
for (i in 1:length(markersPS)){
write.xlsx(markersPS[[i]], file=paste0(wd,"PhD_BPS32/release4/TpositiveCells/csv_markersStage/PrimitiveStreak_MarkersByStage_20180627.xlsx"), sheetName=names(markersPS)[i])
}
library(xlsx)
for (i in 1:length(markersPS)){
write.xlsx(markersPS[[i]],
file=paste0(wd,"PhD_BPS32/release4/TpositiveCells/csv_markersStage/PrimitiveStreak_MarkersByStage_20180627.xlsx"),
sheetName=names(markersPS)[i],append=TRUE)
}
library(xlsx)
for (i in 1:length(markersPS)){
if (i>1){
write.xlsx(markersPS[[i]],
file=paste0(wd,"PhD_BPS32/release4/TpositiveCells/csv_markersStage/PrimitiveStreak_MarkersByStage_20180627.xlsx"),
sheetName=names(markersPS)[i],append=TRUE)
} else{
write.xlsx(markersPS[[i]],
file=paste0(wd,"PhD_BPS32/release4/TpositiveCells/csv_markersStage/PrimitiveStreak_MarkersByStage_20180627.xlsx"),
sheetName=names(markersPS)[i])
}
}
#=====================================
# Early mixed mesoderm
#=====================================
cellsMes0 <- rownames(metaSub)[metaSub$cluster.ann=="Early mixed mesoderm"]
cellsMes0
cellsStageRight <- rownames(metaSub)[metaSub$stage!="mixed_gastrulation"]
save(markersPS,hvg,decompPS,file=paste0(wd,"PhD_BPS32/release4/TpositiveCells/rda/20180627_PrimitiveStreak_markers_by_stage.rda"))
#=====================================
# Early mixed mesoderm
#=====================================
cellsMes0 <- rownames(metaSub)[metaSub$cluster.ann=="Early mixed mesoderm"]
cellsStageRight <- rownames(metaSub)[metaSub$stage!="mixed_gastrulation"]
cellsMes <- intersect(cellsMes0,cellsStageRight)
countsMes0 <- counts[,cellsMes]
cellsMes
counts <- counts0
countsMes0 <- counts[,cellsMes]
countsMes1 <- countsMes0[rowVars(countsMes0)>0,]
source(paste0(wd,"PhD_BPS32/release4/JonnyFiles/20180402/core_functions_Blanca_local.R"))
source(paste0(wd,"PhD_BPS32/release4/JonnyFiles/20180402/core_functions_Blanca_local.R"))
decompMes<- smart_decomp(countsMes1,stage=metaSub[cellsMes,"stage"],
sample=metaSub[cellsMes,"sample"])
hvg <- choose_hvgs(decompMes,return.plots=TRUE)
countsMes <- countsMes1[hvg$hvgs,]
groupsMes <- as.character(metaSub[cellsMes,"stage"])
names(groupsMes)<-cellsMes
markersMes <- anSeq::findMarkers(countsMesS,groups=groupsMes)
markersMes <- anSeq::findMarkers(countsMes,groups=groupsMes)
markersMes2 <- markersMes
for (i in 1:length(markersMes)){
markersMes[[i]]$geneNames <- anSeq::getGeneName(rownames(markersMes[[i]]))[[2]]
}
save(markersMes,hvg,decompMes,file=paste0(wd,"PhD_BPS32/release4/TpositiveCells/rda/20180627_Earlymixedmesoderm_markers_by_stage.rda"))
library(xlsx)
library(xlsx)
for (i in 1:length(markersMes)){
if (i>1){
write.xlsx(markersMes[[i]],
file=paste0(wd,"PhD_BPS32/release4/TpositiveCells/csv_markersStage/Earlymixedmesoderm_MarkersByStage_20180627.xlsx"),
sheetName=names(markersMes)[i],append=TRUE)
} else{
write.xlsx(markersMes[[i]],
file=paste0(wd,"PhD_BPS32/release4/TpositiveCells/csv_markersStage/Earlymixedmesoderm_MarkersByStage_20180627.xlsx"),
sheetName=names(markersMes)[i])
}
}
markersMes <- findMarkers(countsMes,groups=groupsMes)
markersMes2 <- markersMes
for (i in 1:length(markersMes)){
markersMes[[i]]$geneNames <- anSeq::getGeneName(rownames(markersMes[[i]]))[[2]]
}
save(markersMes,hvg,decompMes,file=paste0(wd,"PhD_BPS32/release4/TpositiveCells/rda/20180627_Earlymixedmesoderm_markers_by_stage.rda"))
library(xlsx)
for (i in 1:length(markersMes)){
if (i>1){
write.xlsx(markersMes[[i]],
file=paste0(wd,"PhD_BPS32/release4/TpositiveCells/csv_markersStage/Earlymixedmesoderm_MarkersByStage_20180627.xlsx"),
sheetName=names(markersMes)[i],append=TRUE)
} else{
write.xlsx(markersMes[[i]],
file=paste0(wd,"PhD_BPS32/release4/TpositiveCells/csv_markersStage/Earlymixedmesoderm_MarkersByStage_20180627.xlsx"),
sheetName=names(markersMes)[i])
}
}
library(xlsx)
for (i in 1:length(markersMes)){
if (i>1){
write.xlsx(markersMes[[i]],
file=paste0(wd,"PhD_BPS32/release4/TpositiveCells/csv_markersStage/Earlymixedmesoderm_MarkersByStage_20180627.xlsx"),
sheetName=names(markersMes)[i],append=TRUE)
} else{
write.xlsx(markersMes[[i]],
file=paste0(wd,"PhD_BPS32/release4/TpositiveCells/csv_markersStage/Earlymixedmesoderm_MarkersByStage_20180627.xlsx"),
sheetName=names(markersMes)[i])
}
}
i
length(markersMes)
write.xlsx(markersMes[[i]],
file=paste0(wd,"PhD_BPS32/release4/TpositiveCells/csv_markersStage/Earlymixedmesoderm_MarkersByStage_20180627.xlsx"),
sheetName=names(markersMes)[i])
markersMes[[i]]
markersMes[[2]]
#' @author Blanca Pijuan Sala.
#' @export
#' @rdname findMarkers
#' @import edgeR
#' @importFrom utils combn
#' @importFrom stats p.adjust
findMarkers <- function(counts,genes=NULL,groups,
topGeneThres=1000, logFCThres = 0,
qvalue=0.05, mode="general",groupTarget=NULL){
if (is.null(genes)){
genes <- rownames(counts)
}
#Define groups
uniq.groups <- unique(groups)
#Take those genes to take into account from the counts table.
counts <- counts[genes,]
if (mode == "general"){
#Create an empty matrix where you will add the upregulated genes.
genesDE <- list()
Up.genes <-matrix(, nrow=topGeneThres , ncol = length(uniq.groups))
Down.genes <-matrix(, nrow=topGeneThres , ncol = length(uniq.groups))
if (is.null(groupTarget)){
for (i in c(1:length(uniq.groups))){
groupB <- as.character(uniq.groups[i])
cat (paste("\n\n\nComparing",groupB,"to others...\n"))
groupA <- "other"
groups.bias <- as.character(groups)
names(groups.bias)= names(groups)
groups.bias[names(groups.bias)[which(groups.bias != groupB)]] = groupA
groups.bias <- as.factor(groups.bias)
#Create a DGEList
dgList <- edgeR::DGEList(counts=as.matrix(counts), genes = rownames(counts),
group=groups.bias)
#Estimate dispersions needed for edgeR.
cat("Estimating dispersions...")
dgList <- edgeR::estimateCommonDisp(dgList, verbose=TRUE)
dgList <- edgeR::estimateTagwiseDisp(dgList)
res <- edgeR::exactTest(dgList,pair = c(groupA , groupB))
fdr <- stats::p.adjust(res$table$PValue, method="BH")
res2 <- cbind(res$table,fdr)
res2.sort <- res2[order(res2$fdr,decreasing = FALSE),]
#res2.sort.top <- res2.sort[which(res2.sort$fdr < qvalue),]
#up <- rownames(res2.sort.top[which(res2.sort.top$logFC<(-logFCThres)),])[1:topGeneThres]
#down <- rownames(res2.sort.top[which(res2.sort.top$logFC>(logFCThres)),])[1:topGeneThres]
genesDE[[groupB]] <- res2.sort[res2.sort$fdr<qvalue,]
}
#olnames(Up.genes) = colnames(Down.genes) = uniq.groups
return(genesDE)
} else {
groupB <- groupTarget
cat (paste("\n\n\nComparing",groupB,"to others...\n"))
groupA <- "other"
groups.bias <- as.character(groups)
names(groups.bias)= names(groups)
groups.bias[names(groups.bias)[which(groups.bias != groupB)]] = groupA
groups.bias <- as.factor(groups.bias)
#Create a DGEList
dgList <- edgeR::DGEList(counts=as.matrix(counts), genes = rownames(counts),
group=groups.bias)
#Estimate dispersions needed for edgeR.
cat("Estimating dispersions...")
dgList <- edgeR::estimateCommonDisp(dgList, verbose=TRUE)
dgList <- edgeR::estimateTagwiseDisp(dgList)
res <- edgeR::exactTest(dgList,pair = c(groupA , groupB))
fdr <- stats::p.adjust(res$table$PValue, method="BH")
res2 <- cbind(res$table,fdr)
res2.sort <- res2[order(res2$fdr,decreasing = FALSE),]
res2.sort.top <- res2.sort[which(res2.sort$fdr < qvalue),]
return(res2)
}
cat("DONE!\n")
} else if (mode=="strict"){
#Create a DGEList
dgList <- edgeR::DGEList(counts=as.matrix(counts), genes = rownames(counts),
group=groups)
#Estimate dispersions needed for edgeR.
cat("\n\nEstimating dispersions...\n")
dgList <- edgeR::estimateCommonDisp(dgList, verbose=TRUE)
dgList <- edgeR::estimateTagwiseDisp(dgList)
#Create table for pairwise comparisons (pairs will be unique)
combin <- t(utils::combn(unique(c(uniq.groups,uniq.groups)) , 2 ))
#Reorder columns
combin.inv <- combin[,c(2,1)]
#Take all pairs in one direction and in the other (e.g. row with 6 4 and 4 6)
combin2 <- rbind(combin,combin.inv)
#Create an empty matrix where you will add the upregulated genes.
Up.genes <-matrix(, nrow=topGeneThres , ncol = nrow(combin2))
for (i in c(1:nrow(combin))){
#for each unique combination, define group1 and 2.
group1 <- uniq.groups[combin[i,1]]
group2 <- uniq.groups[combin[i,2]]
res <- edgeR::exactTest(dgList,pair = c( group1 , group2))
fdr <- stats::p.adjust(res$table$PValue, method="BH")
res2 <- cbind(res$table,fdr)
res2.sort <- res2[order(res2$fdr,decreasing = FALSE),]
res2.sort.top <- res2.sort[which(res2.sort$fdr < qvalue),]
up1 <- rownames(res2.sort.top[which(res2.sort.top$logFC<(-logFCThres)),])[1:topGeneThres]
idx1 <- which(((combin2[,1]==combin[i,1])&(combin2[,2]==combin[i,2]))==TRUE)
Up.genes[,idx1] <- up1
up2 <- rownames(res2.sort.top[which(res2.sort.top$logFC>(logFCThres)),])[1:topGeneThres]
idx2 <- which(((combin2[,1]==combin[i,2])&(combin2[,2]==combin[i,1]))==TRUE)
Up.genes[,idx2] <- up2
}
up.genes.merged <- list()
for (t in 1:length(uniq.groups)){
num <- length(which(combin2[,1]==t))
tab <- table(as.vector(Up.genes[,which(combin2[,1]==t)]))
up.genes.merged[[t]] <- names(tab)[which(tab == num)]
if (is.null(names(tab)[which(tab == num)])){
up.genes.merged[[t]] = c("none")
}
}
names(up.genes.merged)<-uniq.groups
return(list(
up.genes <- up.genes.merged
))
cat("DONE!\n")
}
}
library(xlsx)
for (i in 1:length(markersMes)){
if (nrow(markersMes[[i]])>0){
if (i>1){
write.xlsx(markersMes[[i]],
file=paste0(wd,"PhD_BPS32/release4/TpositiveCells/csv_markersStage/Earlymixedmesoderm_MarkersByStage_20180627.xlsx"),
sheetName=names(markersMes)[i],append=TRUE)
} else{
write.xlsx(markersMes[[i]],
file=paste0(wd,"PhD_BPS32/release4/TpositiveCells/csv_markersStage/Earlymixedmesoderm_MarkersByStage_20180627.xlsx"),
sheetName=names(markersMes)[i])
}
}
}
boxplot(countsPS["ENSMUSG00000075588",]~groupsPS)
setwd("/Users/blancap/Documents/repos_bitbucket/r-packages/00.PACKAGES/anSeq_development/anSeq")
roxygen2::roxygenize()
install.packages('roxygen2')
roxygen2::roxygenize()
roxygen2::roxygenize()
setwd("/Users/blancap/Documents/repos_bitbucket/r-packages/00.PACKAGES/anSeq_development/anSeq")
roxygen2::roxygenize()
setwd("/Users/blancap/Documents/repos_bitbucket/r-packages/00.PACKAGES/anSeq_development/anSeq")
roxygen2::roxygenize()
setwd("/Users/blancap/Documents/repos_bitbucket/r-packages/00.PACKAGES/anSeq_development/anSeq")
roxygen2::roxygenize()
setwd("/Users/blancap/Documents/repos_bitbucket/r-packages/00.PACKAGES/anSeq_development/anSeq")
roxygen2::roxygenize()
??devtools::use_data
install.packages('devtools::use_data')
install.packages('devtools')
??devtools::use_data
########################################################################################
## Title: external_data_save.R
## Author: Blanca Pijuan-Sala
## Description: Save external data.
## Date: 30 September 2017
## **anSeq package**
########################################################################################
###SAVE INTERNAL DATASET.
#http://r-pkgs.had.co.nz/data.html
wd <- "/Users/blancap/Documents/repos_bitbucket/r-packages/00.PACKAGES/anSeq_development/anSeq/"
geneTable <- read.csv(paste0(wd,"inst/extdata/mm10_mart_export.txt"))
setwd(paste0(wd,"R/"))
library(devtools)
#####
tableRef="/Users/blancap/Documents/PhD_CAMBRIDGE/PhD/Experiments/bin_data/surfaceomeproteins_wlabethz_File.xlsx"
species="Mouse"
tab = "Table B"
tableRef <- xlsx::read.xlsx(tableRef,sheetName = tab)
MouseSurface <- tableRef$CSPA.category
names(MouseSurface) <- tableRef$ENTREZ.gene.symbol
#============
tableRef="/Users/blancap/Documents/PhD_CAMBRIDGE/PhD/Experiments/bin_data/surfaceomeproteins_wlabethz_File.xlsx"
species="Human"
tab = "Table A"
tableRef <- xlsx::read.xlsx(tableRef,sheetName = tab)
HumanSurface <- tableRef$CSPA.category
names(HumanSurface) <- tableRef$ENTREZ.gene.symbol
setwd(paste0(wd,"R/"))
library(devtools)
devtools::use_data(MouseSurface,HumanSurface,geneTable, internal = TRUE)
devtools::use_data(MouseSurface,HumanSurface,geneTable, internal = TRUE,
overwrite = TRUE)
setwd("/Users/blancap/Documents/repos_bitbucket/r-packages/00.PACKAGES/anSeq_development/anSeq")
roxygen2::roxygenize()
